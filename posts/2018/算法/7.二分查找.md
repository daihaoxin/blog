# 二分查找
```javascript
function bsearch(arr, n, value) {
  let low = 0
  let high = n - 1

  while(low <= high) {
    // const mid = (high + low) / 2 有溢出风险
    const mid = low + (high - low) / 2
    if (arr[mid] === value) {
      return mid
    } else if (arr[mid] < value) {
      low = mid + 1
    } else {
      high = mid - 1
    }
  }

  return -1
}
```

## 性能分析
二分查找的时间复杂度为O(logN)，查找效率非常高，但是并不是万能的。

首先，采用二分查找的数据必须是数组的形式，只有数组才能使用下标的方式直接访问到数据，此时只需要O(1)的时间即可访问到数据。如果使用链表，则必须顺序访问，直到访问到数据。

另外，二分查找的数据必须是排好序的，而且应该是没有频繁插入和删除操作的数据。

再次，数据量太小了也不适合二分查找，数据量太小，用二分查找和顺序查找也不会看出有多大的区别。但是如果你每次数据的比较都是一个非常耗时的操作，那么二分查找就好一些了，毕竟它减少了对比的次数。

最后，数据量太大也不适合用二分查找。因为二分查找要求数据是连续的，即在内存中是连续的，如果我们的数组有1G的大小，也就导致了我们需要使用1G的连续内存空间来存放数据。

## 变形
#### 查找第一个值等于给定的值的元素
如1，3，4，5，6，8，8，8，11，18

加入我们要查找第一个值等于8的元素，依照之前的算法，会算出结果为7，即a[7] === 8，这是不对的。

```javascript
function bsearch(arr, n, value){
  let low = 0
  let hgih = n - 1
  
  while(low <= high) {
    const mid = low + (high - low) / 2
    if (arr[mid] > value) {
      high = mid - 1
    } else if (arr[mid] < value) {
      low = mid + 1
    } else {
      if (mid === 0 || (arr[mid - 1] !== value)) {
        return mid
      } else high = mid - 1
    }
  }

  return -1
}
```
#### 查找最后一个值等于给定的值的元素
```javascript
function bsearch(arr, n, value) {
  let low = 0
  let hgih = n - 1

  while(low <= high) {
    const mid = low + (high - low) / 2
    if (arr[mid] > value) {
      high = mid - 1
    } else if (arr[mid] < value) {
      low = mid + 1
    } else {
      if (mid === n - 1 || (arr[mid + 1] !== value)) {
        return mid
      } else low = mid + 1
    }
  }

  return -1
}
```

#### 查找第一个大于等于给定值得元素
例如有数据：3，4，6，7，10。要查找第一个大于等于5的元素，即为6。

```javascript
function bsearch(arr, n, value) {
  let low = 0
  let hgih = n - 1

  while(low <= high) {
    const mid = low + (high - low) / 2
    if (arr[mid] >= value) {
      if (mid === 0 || arr[mid - 1] < value) {
        return mid
      } else high = mid - 1
    } else {
      low = mid + 1
    }
  }

  return -1
}
```

#### 查找最后一个小于等于给定值得元素
假如有数据：3，5，6，8，9，10。最后一个小于等于7的元素是6

```javascript
function bsearch(arr, n, value) {
  let low = 0
  let hgih = n - 1

  while(low <= high) {
    const mid = low + (high - low) / 2
    if (arr[mid] <= value) {
      if (mid === n - 1 || arr[mid + 1] > value) {
        return mid
      } else low = mid + 1
    } else {
      high = mid - 1
    }
  }

  return -1
}
```
