# 快速排序
快速排序也是采用分治法来进行排序，和归并排序有点像。  
归并排序是将一个数组分为两个子数组分别排序，不断切分数组进行排序组合，最后将两个有序的子数组合并成一个完整的数组。  
快速排序则选定一个切分元素，也会切分两个数组，左子数组小于切分元素，右子数组大于切分元素，将这两个子数组排序，最后合并成完整数组。

由此可以见，这个切分元素非常重要，这个切分元素也叫基准值，这个基准值找得好，快速排序将会很高效，否则将会变得很慢。  
理想状态下，快速排序运行时间为O(NlogN)，最坏情况下为O(n^2)。

**何为理想情况？何为最坏情况**  
理想情况即这个基准值能够将你的数组平分为2部分；  
最坏情况是数组是有序数组，而你选取基准值的方式是选取数组第一个元素，这就导致你每次都会造成左数组为空，右数组为原始数组的情况。
```
12345678
[]①2345678
   []②345678
      []④5678
      ...
          []⑥78
```
明显，在这个调用栈里，每层都会涉及到O(N)个元素，总共N层，即O(N^2)  
换个情况
```
12345678
123[4]5678
1[2]3 5[6]78
         [7]8 
```
这时我们的调用栈只需要4层，经过数学证明的是，理想情况下总过会有O(logN)层，每层的栈长依旧是O(N)，因此总共为O(NlogN)

**如何避免最坏情况的发生？**  
一般我们会将数组打乱，避免其实有序的。另外如果数组元素较少的情况下，可以采用插入排序，插入排序对于元素较少的集合会相对比归并和快速排序高效一些。

**归并排序一直都是O(NlogN)的运行时间，为什么不选择直接用归并排序？**
归并排序不是就地算法，即它需要引入额外的空间（和待排序的数组相同）O(N)来换取快速的排序时间，是一种空间换时间的做法，这在集合非常大的时候很不可取。  
而快速排序是一种就地排序，不需要额外的空间，或者说只需要常数级别的空间O(1)，在原数组下即可完成排序。平均情况下只需要O(NlogN)

## 快速排序算法
已经有很多成熟的库来帮助我们实现快速排序算法，我们自己实现估计也没有其他人实现得好，毕竟他们的是经过数学和实践证明的。

但是我们还是可以自己来理解下基本的快速排序怎么实现，理解思想即可。

我们知道快速排序最重要的就是实现基准元素的选取，我们就简单点每次都获取第一个元素作为基准元素。

```javascript
function partition(arr, lo, hi) {
  const item = arr[lo]
  let i = lo
  let j = hi + 1

  while (true) {
    while(arr[++i] < item) if(i === hi) break
    while(arr[--j] > item) if(j === lo) break
    if (i >= j) break
    
    const tmp = arr[i]
    arr[i] = arr[j]
    arr[j] = tmp
  }

  const tmp = arr[lo]
  arr[lo] = arr[j]
  arr[j] = tmp
  return j
}

function sort(arr, lo, hi) {
  if (lo >= hi) return

  const j = partition(arr, lo, hi)
  sort(arr, lo, j)
  sort(arr, j + 1, hi)
}
```

## 有重复元素时
如果我们的集合序列中存在大量的重复元素，采用快速排序可能会得不偿失，因为它依旧会不断去执行迭代排序，最终有可能会将算法复杂度上升为O(N^2)

这时我们可以采用*三项切分*，将元素切分为三部分`a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]`

```java
public class Quick3Way {
  private static void sort(Comparable[] a, int lo, int hi) {
    if (hi <= lo) return;

    int lt = lo, i = lo + 1, gt = hi;
    Comparable v = a[lo]

    while(i <= gt) {
      int cmp = a[i].compareTo(v)

      if (cmp < 0) exchange(a, lt++, i++);
      if (cmp > 0) exchange(a, i, gt--);
      else i++;
    } // a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]

    sort(a, lo, lt - 1)
    sort(a, gt + 1, hi)
  }
}
```

![WX20180802-190001](../images/WX20180802-190001.png)

如果有大量的重复内容时，三项切分可以将复杂度有对数时间降级为线性时间。