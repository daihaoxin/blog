# 插入排序
将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。

插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。

注意插入排序在拿到每一个需要插入的数据时，被插入的序列是已经排好序了。另外插入排序是一种就地排序，即它无需引入其他额外空间（如不需要再引入一个数组）。

```javascript
function insertSort(array) {
  for (let i = 1; i < array.length; i++) {
    const item = array[i]
    let j = i - 1 

    while (item < array[j]) {
      array[j + 1] = array[j]

      if (j-- === 0) {
        break
      }
    }

    array[j + 1] = item
    console.log(array)
  }

  return array
}
```

输出结果如下
```
[ 2, 5, 4, 6, 1, 3 ]
[ 2, 4, 5, 6, 1, 3 ]
[ 2, 4, 5, 6, 1, 3 ]
[ 1, 2, 4, 5, 6, 3 ]
[ 1, 2, 3, 4, 5, 6 ]
```

## 运行时间分析
最坏情况分析（加入数据都是倒序，如：5,4,3,2,1）：
1. 最外层的循环，需要循环n次，因此为O(n)
1. 接着在while之前的代码，由于需要循环n次运行，因此这些代码也是运行n次，也为O(n)
1. 接着就是while处的代码，最坏情况下，每次都需要移动前面所有的序列，即需要移动1+2+...+(n-1)=(n^2)/2，即为O(n^2)
1. while内部的代码也是跟随while的运行次数O(n^2)
1. 剩余的代码即为O(n)
1. 将以上所有相加，取主要影响因素，即为O(n^2)，所以最坏情况下，插入排序的运行时间为O(n^2)

最好情况分析（加入的数据都是顺序，如：1,2,3,4,5）:
1. 最外层的循环，需要循环n次，因此为O(n)
1. 接着在while之前的代码，由于需要循环n次运行，因此这些代码也是运行n次，也为O(n)
1. 接着就是while处的代码，最好的情况，while每次都不会成立，在外层循坏里面只执行一次，总共n次，即O(n)
1. while内部代码不执行
1. 剩余的代码即为O(n)
1. 将以上所有相加，取主要影响因素，即为O(n)，所以最好情况下，插入排序的运行时间为O(n)
