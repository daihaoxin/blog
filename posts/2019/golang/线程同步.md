# 关于线程同步
在支持多线程变成语言，例如c++、java等，在访问同一个资源的时候，就会出现不一致。我们称这种资源为**共享资源**，而操作这些资源的代码区块，我们称之为**临界区（Critical section）**。

go作为一种支持协程的语言，天然也需要处理这种情况。  
```go
var x = 1
func increment() {
  x = x+1
  fmt.Println(x)
}

for i:=0; i < 10; i++ {
    go increment()
}
```

像上面的这段代码，我们可能期望i是递增打印出来的。但是由于我们没有对`increment()`做任何控制，也即没有对这块临界区做任何处理，导致多个协程同时操作这块区域，得到不一致的结果，这种情况我们称之为**竞态条件（Race condition）**

# 互斥锁（Mutex）
解决竞态条件的最简单的方式就是加锁，在进入临界区时需要对区域加锁，离开区域后释放锁。其他线程进入临界区后，先判断锁是否被持有，如果是则等待该锁释放再来获取。

```go
var m sync.Mutex
var x = 1
func increment() {
  m.Lock()
  x = x+1
  fmt.Println(x)
  m.Unlock()
}
```

不过我们一般会这么写
```go
var m sync.Mutex
var x = 1
func increment() {
  m.Lock()
  defer m.Unlock()
  x = x+1
  fmt.Println(x)
}
```
通过defer，确保在函数结束后一定会释放锁。

需要注意的是，golang的互斥锁是不可重入锁（non-recursive）。像java的synchronized就是可重入锁，对于同一个线程，是可以重复加锁的。

为什么go不支持可重入锁呢？创始人认为如果需要使用可重入锁，那么首先应该先审视下自己的代码是不是写的有问题。而且可重入锁也有可能带来不一致情况。本来我们使用锁就是为了解决竞态条件，如果该锁为可重入锁，反而又引发了竞态条件。

```go
func F() {
    m.Lock()
    ... do some stuff ...
    G()
    ... do some more stuff ...
    m.Unlock()
}

func G() {
    m.Lock()
    ... do some stuff ...
    m.Unlock()
}
```
如果go支持可重入锁，那么该`F()`和`G()`都可以成功执行，但是这种代码设计是不合理的，试想如果`F()`和`G()`都还会涉及操作某个共享变量会如何，例如之前的x+1操作，会得到不一致的结果。但是由于程序没有异常，我们却没有意识bug已经发生。

而如果是不可重入的，就直接引发了死锁。虽然死锁看起来让人很不舒服，但是却有效避免了一些情况的发生，更加容易发现问题。

如果我们真的需要调用G如何办，那我们只能委婉的实现多一个不加的G功能。
```go
func F() {
    m.Lock()
    ... do some stuff ...
    g()
    ... do some more stuff ...
    m.Unlock()
}

func G() {
    m.Lock()
    g()
    m.Unlock()
}

func g() {
    ... do some stuff ...
}
```

# 条件变量（Condition variable）
条件变量和互斥锁一样，都是一种同步工具，而它必须配合互斥锁一起使用才能发挥作用。条件变量不是用来保护临界区和共享资源的，而是用于协调想要访问共享资源的那些线程。

当共享资源的状态发生变化的时候，它可以用来通知被互斥锁阻塞的线程。因此条件变量还有个学名，叫管程（montior）。

在之前使用互斥锁的时候，如果资源已经被上锁，那么想要获取到资源的锁就必须定时轮训查看锁是否被释放，这种方式效率比较低。而如果使用条件变量，线程只需要等待接收通知即可，当锁被释放时，线程会接收到通知，这种方式比之前轮训的方式高效。

在golang中（其他语言如Java也大多如此），条件变量包含三个api：
1. wait()，等待通知
2. notify()，发送通知
3. Broadcast()，发送群发通知，有些语言（如c++）可能叫notifyAll()

简单的例子：
```go
var m sync.Mutex
cond := sync.NewCond(&m)
isEmpty := false

go func notify() {
    cond.L.Lock()
    isEmpty = true
    cond.Signal()
    cond.L.Unlock()
}()

cond.L.Lock()
for !isEmpty {
    // 这一步会原子地unlock mutex并进入等待
    // 不会因上述notify的调用导致死锁
    // wait在执行结束后会重新加锁
    cond.Wait()
}
fmt.Println(isEmpty)
cond.L.Unlock()
```

这里有几点需要注意，对于wait的一端：
1. 必须与mutext一起使用，该布尔表达式的读写受此mutex的保护。
2. 在调用Wait前需要先加锁。
3. 把判断布尔条件和wait放入循环中，如go中的for语句中。

看一下Wait函数的源码
```go
func (c *Cond) Wait() {
    c.checker.check()
    t := runtime_notifyListAdd(&c.notify)
    c.L.Unlock()
    runtime_notifyListWait(&c.notify, t)
    c.L.Lock()
}
```
可见是先进行了解锁再进行等待，之后又重新上锁。

至于为什么需要使用循环，而不是使用if语句来判断条件。  
主要是因为if语句只会检查状态一次，而for的话可以进行多次检查。  
由于线程或者goroutine可能并不是因为调用了notify才被唤醒，而是操作系统自行将其唤醒，而此时的状态可能还是不对的，这种情况称之为“伪唤醒（Spurious wakeup）”，此时应该再次调用Wait方法进入等待。因此为了保险起见，在包裹条件变量的Wait方法总是应该使用for语句。

参考[https://en.wikipedia.org/wiki/Spurious_wakeup](https://en.wikipedia.org/wiki/Spurious_wakeup)

对于signal或者broadcast的一端：
1. 不一定要在mutex已上锁的情况下调用signal
2. 在signal之前一定要修改判断变量（如上述的isEmpty被修改为true）
3. 修改判断变量通常需要mutex进行保护。
4. 注意区分signal和broadcast，broadcast通常用作表明状态变化，signal通常用于表示资源可用。

# 读写锁（RWMutex）
顾名思义，它区分了锁的类型，对于只有只读功能的临界区，可以使用读锁。而有更新操作的临界区则可以使用写锁。而读锁可以多次加锁，而写锁会被阻塞。

```go
var m sync.RWMutex
var x = 1

func Increment() {
    m.Lock()
    defer m.Unlock()
    x = x+1
    fmt.Println(x)
}
func GetX() int {
    m.RLock()
    defer m.RUnlock()
    y := x * 2
    return y
}

for i:=0; i < 10; i++ {
    go Increment()
}
```
如上述代码，修改x时，采用了写锁，而读取的时候使用了读锁。

但是使用读写锁需要注意：
1. 小心在采用读锁的地方对数据进行修改，有时为了新增功能这很容易发生。这会导致数据和没有加锁一样的情况。
2. 读写锁并不一定比普通的mutex高效。如果临界区较小，mutex往往会更快
   
如果确实对并发读写有极高的性能要求，可以考虑使用read-copy-update技术，这是一种无锁技术方案，linux底层也在使用。  
就是指读-拷贝修改，它是基于其原理命名的。对于被RCU保护的共享数据结构，读操作不需要获得任何锁就可以访问，但写操作在访问它时首先拷贝一个副本，然后对副本进行修改，最后在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作。
